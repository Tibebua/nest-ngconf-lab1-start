<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Amazing Backends for Angular Devs Workshop with NestJS</title>
    <link type="text/css" rel="stylesheet" href="assets/css/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/css/atom-one-dark.min.css" />
    <script src="assets/js/highlight.min.js"></script>
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/copyToClipboard.js"></script>
    <script src="assets/js/createButtons.js"></script>
    <script>
      // hljs.initHighlightingOnLoad();
    </script>
  </head>
  <body>
    <div class="main-body">
      <div class="toc">
        <ul class="nav nav-list">
            <li class="sidebar-header-2"><a href="#prerequisites">Prerequisites</a></li>
            <li class="sidebar-header-2"><a href="#introduction">Introduction</a></li>
            <li class="sidebar-header-2"><a href="#meet-nest">Meet Nest</a></li>
            <li class="sidebar-header-2"><a href="#meet-ionic">Meet Ionic</a></li>
            <li class="sidebar-header-2"><a href="#lab-1">Lab 1</a></li>
            <li class="sidebar-header-2"><a href="#lab-2">Lab 2</a></li>
            <li class="sidebar-header-2"><a href="#lab-3">Lab 3</a></li>
            <li class="sidebar-header-2"><a href="#lab-4">Lab 4</a></li>
            <li class="sidebar-header-2"><a href="#conclusion">Conclusion</a></li>
        </ul>      </div>
      <div class="content"><h1 id="amazing-backends-for-angular-devs-workshop-with-nestjs"><a class="header-link" href="#amazing-backends-for-angular-devs-workshop-with-nestjs"></a>Amazing Backends for Angular Devs Workshop with NestJS</h1>
<h2 id="prerequisites"><a class="header-link" href="#prerequisites"></a>Prerequisites</h2>
<p>You need a recent version of Node installed (this is tested with Node 10 but might work with Node 8). Visit <a href="https://nodejs.org/en/">Node&#39;s website</a> to install it.</p>
<p>To begin, clone the starter app from Github:</p>
<pre class="hljs"><code>git <span class="hljs-built_in">clone</span> https://github.com/elylucas/nest-ngconf.git</code></pre><p><copy-button></copy-button></p>
<p>Go into the <code>nest-ngconf</code> directory and install dependencies:</p>
<pre class="hljs"><code><span class="hljs-built_in">cd</span> nest-ngconf
npm install</code></pre><p><copy-button></copy-button></p>
<p>To start the dev server for both Ionic and Nest, run:</p>
<pre class="hljs"><code>npm run dev</code></pre><p><copy-button></copy-button></p>
<p>Any changes you make to your project will automatically be recompiled when you save.</p>
<p>That&#39;s all!</p>
<h2 id="introduction"><a class="header-link" href="#introduction"></a>Introduction</h2>
<p>In this workshop, we will cover how to build out a full-stack TypeScript application using Angular, Ionic, and NestJS. As Angular devs, you already know how powerful TypeScript is. We will take the power of TypeScript and learn how to use it on the backend.</p>
<h2 id="meet-nest"><a class="header-link" href="#meet-nest"></a>Meet Nest</h2>
<p><a href="https://nestjs.com">NestJS</a> (just Nest from here on out), is a Node framework meant to build server-side applications. Not only is it a framework, but it is also a platform to meet many backend application needs, like writing APIs, building microservices, or doing real-time communications through web sockets. For us Angular devs, it is an excellent solution to write our backends with because it fits in so well with the rest of our ecosystem.</p>
<h2 id="meet-ionic"><a class="header-link" href="#meet-ionic"></a>Meet Ionic</h2>
<p><a href="https://ionicframework.com">Ionic</a> is a UI framework for building mobile first web applications. Ionic provides around 100 UI widgets that give your app a native user experience and lets you code with the technologies you know and love, like Angular, TypeScript, and HTML/CSS. With Ionic, you can create native iOS, Android, and Progressive Web Apps with one code base.</p>
<p>We will use Ionic in this workshop as our UI library. However, no previous experience with Ionic is required.</p>
<h2 id="lab-1"><a class="header-link" href="#lab-1"></a>Lab 1</h2>
<blockquote>
<p>Start with the <code>master</code> branch and run <code>npm run dev</code> to start the Nest and Angular dev servers.</p>
</blockquote>
<h3 id="nest-missions-service"><a class="header-link" href="#nest-missions-service"></a>Nest Missions Service</h3>
<p>Nest services are much like Angular services. They are simple classes that can be registered in the app module&#39;s providers, which lets them be injected into other components. Services are the ideal place for interacting with the database layer, performing business logic, or making calls into other APIs.</p>
<p>Open the <code>MissionService</code> file and add the <code>getMissions</code> method:</p>
<!-- gsr-nest-missions-service-getMissions -->
<p><code>src/server/app/missions/missions.service.ts</code></p>
<pre class="hljs"><code>getMissions() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsRepository.getList();
}</code></pre><p><copy-button></copy-button></p>
<p>In this service class, we make use of the <code>MissionsRepository</code>, which is already provided as a part of the base solution. The purpose of this class is to provide a &quot;fake&quot; database for us to use, so we don&#39;t have to go through setting one up. The specifics of this class are outside the scope of this workshop.</p>
<h3 id="missions-nest-controller"><a class="header-link" href="#missions-nest-controller"></a>Missions Nest Controller</h3>
<p>Open up the <code>MissionController</code> and note that it is has <code>@Controller(&#39;missions&#39;)</code> as a decorator on the class. This decorator instructs Nest that this class is responsible for requests at the /missions` endpoint.</p>
<p>Next, add the GET handler in the <code>MissionController</code> class:</p>
<!-- gsr-nest-missions-controller-getMissions -->
<p><code>src/server/app/missions/missions.controller.ts</code></p>
<pre class="hljs"><code><span class="hljs-meta">@Get</span>()
async getMissions() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.getMissions();
}</code></pre><p><copy-button></copy-button></p>
<p>The <code>@Get</code> decorator on the <code>getMissions</code> method states that this is the method that will response to GET requests.</p>
<p>Open your browser to <a href="http://localhost:3000/missions">http://localhost:3000/missions</a>, and you should see a list of missions returned.</p>
<p>Notice, however, there is some meta-data on the model (the createdAt and createdBy fields), and we might not want this data returned to the client. The <code>MissionsRepository</code> is returning a type of <code>MissionEntity</code> (located at <code>src/server/app/data/mission.entity.ts</code>) from the get methods. We can use the <code>class-transformer</code> library to &quot;exclude&quot; certain members of the class from being returned. </p>
<p>Open up the <code>MissionEntity</code> class, and add <code>@Exclude()</code> decorator to the <code>createdAt</code> and <code>createdBy</code> members like so:</p>
<p><code>src/server/app/data/mission.entity.ts</code></p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MissionEntity {
  id?: <span class="hljs-built_in">number</span>;
  title: <span class="hljs-built_in">string</span>;
  reward: <span class="hljs-built_in">number</span>;
  active: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-meta">@Exclude</span>()
  createdAt: <span class="hljs-built_in">Date</span>;
  <span class="hljs-meta">@Exclude</span>()
  createdBy: <span class="hljs-built_in">string</span>;
}</code></pre><p><copy-button></copy-button></p>
<p>For the properties to be excluded, we must run them through the <code>classToPlain</code> function from the <code>class-transformer</code> library. </p>
<p>We could run <code>classToPlain</code> in the controller like so:</p>
<pre class="hljs"><code><span class="hljs-meta">@Get</span>()
async getMissions() {
  <span class="hljs-keyword">const</span> missionEntities = await <span class="hljs-keyword">this</span>.missionsService.getMissions();
  <span class="hljs-keyword">const</span> missions = classToPlain(missionEntities);
  <span class="hljs-keyword">return</span> missions;
}</code></pre><p>However, this adds some cruft to our controller methods. We would have to repeat this code everywhere we return a mission, and repeating code violates the DRY (don&#39;t repeat yourself) principle.</p>
<p>Fortunately, Nest provides a mechanism called interceptors that allow manipulation of data before being returned in the request. 
Let&#39;s take a look at building one next.</p>
<h3 id="nest-interceptors"><a class="header-link" href="#nest-interceptors"></a>Nest Interceptors</h3>
<p>Nest interceptors are pretty much what they sound like; they intercept data from the controllers and let you inspect and modify that data.</p>
<p>We will use an interceptor to run the <code>classToPlain</code> method after the controller has processed the request.</p>
<p>Update the <code>intercept</code> method in <code>DataInterceptor</code> to the following:</p>
<!-- gsr-nest-data-interceptor-intercept -->
<p><code>src/server/app/util/data.interceptor.ts</code></p>
<pre class="hljs"><code>intercept(context: ExecutionContext, next: CallHandler): Observable&lt;<span class="hljs-built_in">any</span>&gt; {
  <span class="hljs-keyword">return</span> next.handle().pipe(
    map(data =&gt; {
      <span class="hljs-keyword">return</span> {
        data: classToPlain(data)
      };
    })
  );
}</code></pre><p><copy-button></copy-button></p>
<blockquote>
<p>Import <code>map</code> from &#39;rxjs/operators&#39; and <code>classToPlain</code> from &#39;class-transformer&#39;</p>
</blockquote>
<p>The <code>next.handle()</code> method is an observable stream that you can interact with like any other observable. Here, we use the <code>map</code> operator from RXJS to transform the output from one object to another. Specifically, we are using <code>classToPlain</code> to have <code>class-transformer</code> remove the excluded params from <code>MissionEntity</code>, just like the controller did earlier. </p>
<p>We are also modifying the returned object to return an object that now has a <code>data</code> property on it, which contains the original response. Optionally, we can now return other properties the could be meta-data about the response, such as a request id or the time it took the request to complete.</p>
<p>To use the <code>DataInterceptor</code>, Nest provides a few different options to bind it to a request. </p>
<p>We can use the <code>@UseInterceptors</code> decorator and either put it on a class if we want it to apply to the entire controller like so:</p>
<pre class="hljs"><code><span class="hljs-meta">@UseInterceptors</span>(DataInterceptor)
<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'missions'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MissionsController { ... }</code></pre><p>Alternatively, we can be more selective and put it only on the route handlers we want:</p>
<pre class="hljs"><code><span class="hljs-meta">@UseInterceptors</span>(DataInterceptor)
<span class="hljs-meta">@Get</span>()
async getMissions() { ... }</code></pre><p>A third option allows us to apply the interceptor to run globally by specifying it in the app module:</p>
<p><code>src/server/app/app.module.ts</code></p>
<pre class="hljs"><code><span class="hljs-meta">@Module</span>({
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: DataInterceptor,
    },
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule {}</code></pre><p>This method is already setup in the demo project for the <code>DataInterceptor</code> and all the other pieces of Nest middleware we will implement in this workshop, so no need to do this yourself.</p>
<p>Hit the <code>/missions</code> endpoint again and you should see the list of missions minus the <code>createdAt</code> and <code>createdBy</code> meta-data.</p>
<p>Now that we have mission data returning from our API let&#39;s consume it from our Ionic app.</p>
<h3 id="mission-interface"><a class="header-link" href="#mission-interface"></a>Mission Interface</h3>
<p>We want to use a common model between our server and client to represent a Mission. However, we don&#39;t want to use the MissionEntity as that has member variables that aren&#39;t returned via the API (the <code>createdAt</code> and <code>createdBy</code> members) and it also has a dependency on the <code>class-transformer</code> library, which we don&#39;t want to import into our client app if we don&#39;t need to. Therefore, we create a lightweight mission interface that can be used from both our front and back ends.</p>
<p>There is a <code>Mission</code> interface already defined in the shared folder:</p>
<p> <code>src/shared/models/mission.model.ts</code></p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Mission {
  id?: <span class="hljs-built_in">number</span>;
  title: <span class="hljs-built_in">string</span>;
  reward: <span class="hljs-built_in">number</span>;
  active: <span class="hljs-built_in">boolean</span>;
}</code></pre><p>The <code>MissionEntity</code> database model implements this interface already to help make sure the main properties for a Mission stay consistent.</p>
<h3 id="update-mission-angular-service-to-retrieve-missions"><a class="header-link" href="#update-mission-angular-service-to-retrieve-missions"></a>Update Mission Angular Service to Retrieve Missions</h3>
<blockquote>
<p>Take note that we have multiple files with the same name in this solution (one in the client and one in the server), so make sure you are in the right file! </p>
</blockquote>
<p>Next, update the <strong>client</strong> <code>MissionsService</code> to retrieve the Missions from the API. Add the <code>getMissions</code> method:</p>
<!-- gsr-ng-missions-service-getmissions -->
<p><code>src/client/app/services/missions.service.ts</code></p>
<pre class="hljs"><code>getMissions() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
    .get&lt;{ data: Mission[] }&gt;(<span class="hljs-string">'http://localhost:3000/missions'</span>)
    .pipe(map(response =&gt; response.data));
}</code></pre><p><copy-button></copy-button></p>
<h3 id="update-home-page"><a class="header-link" href="#update-home-page"></a>Update Home Page</h3>
<p>Next, modify the <code>home.page.ts</code> ngOnInit method to call into the service and save the results to a local observable:</p>
<!-- gsr-ng-missions-controller-oninit -->
<p><code>src/client/app/home/home.page.ts</code></p>
<pre class="hljs"><code>ngOnInit() {
  <span class="hljs-keyword">this</span>.missions = <span class="hljs-keyword">this</span>.missionsService.getMissions();
}</code></pre><p><copy-button></copy-button></p>
<p>The home page template is already setup to display the data. Feel free to browse through it:</p>
<p><code>src/client/app/home/home.page.html</code></p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">ion-header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ion-toolbar</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ion-buttons</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"start"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-menu-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-menu-button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ion-buttons</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ion-title</span>&gt;</span>Missions<span class="hljs-tag">&lt;/<span class="hljs-name">ion-title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ion-buttons</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"end"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ion-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-icon</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ion-buttons</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ion-toolbar</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ion-header</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ion-content</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ion-list</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ion-item</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let mission of (missions | async)"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{{ mission.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ mission.reward | currency }} - {{ mission.active ? 'Active' : 'Complete'}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ion-label</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-icon</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"start"</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"rocket"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-icon</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ion-item</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ion-list</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ion-content</span>&gt;</span></code></pre><p>If you don&#39;t already have a browser window opened to <a href="http://localhost:8100">http://localhost:8100</a>, go ahead and do so. You should now see the list of missions.</p>
<p>That is a great start! Next, we will look into display a mission in its own form.</p>
<h3 id="lab-1-bonus-exercise"><a class="header-link" href="#lab-1-bonus-exercise"></a>Lab 1 Bonus Exercise</h3>
<p>Update the <code>DataInterceptor</code> class to return the time that it took to process the request. Before the call to <code>next.handle()</code>, get the start time, and during the <code>map</code>, get the end time. Use the difference between these variables to represent the number of milliseconds the time of the request took, and return it with the response.</p>
<p>Check the lab1-complete branch for the complete lab1 code and the solution to the exercise.</p>
<h2 id="lab-2"><a class="header-link" href="#lab-2"></a>Lab 2</h2>
<blockquote>
<p>To start fresh at lab2, you can checkout the lab2-start branch in git</p>
</blockquote>
<p>We now have a list of missions displayed. Next, let&#39;s add to our API to retrieve a single mission by its id, and display the mission in a form.</p>
<h3 id="update-nest-service-and-controller-to-get-single-mission"><a class="header-link" href="#update-nest-service-and-controller-to-get-single-mission"></a>Update Nest Service and Controller to get Single Mission</h3>
<p>Open up the <strong>server</strong> <code>MissionService</code> and add the following method to fetch a single mission from the repository:</p>
<!-- gsr-nest-missions-service-getmission -->
<p><code>src/server/app/missions/missions.service.ts</code></p>
<pre class="hljs"><code>getMission(id: <span class="hljs-built_in">number</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsRepository.get(id);
}</code></pre><p><copy-button></copy-button></p>
<p>Update the <code>MissionController</code> to call into this new service method:</p>
<!-- gsr-nest-missions-controller-getmission -->
<p><code>src/server/app/missions/missions.controller.ts</code></p>
<pre class="hljs"><code><span class="hljs-meta">@Get</span>(<span class="hljs-string">':id'</span>)
async getMission(<span class="hljs-meta">@Param</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">number</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.getMission(id);
}</code></pre><p><copy-button></copy-button></p>
<p>The <code>Get()</code> decorator here takes in a route parameter named <code>id</code>, and in the <code>getMission</code> method, we extract that parameter out using the new <code>@Param</code> decorator, which in turn assigns the value to <code>id</code>.</p>
<p>If you request <a href="http://localhost:3000/missions/1">http://localhost:3000/missions/1</a>, you should notice that nothing comes back. Why? Parameters are passed in as strings, but we expect the <code>id</code> to be a number, and the repo does not find the mission because of it. In the params to <code>getMission</code>, <code>id</code> is of type number, but, unfortunately, we are practically lying to TypeScript that the value is coming in as a number.</p>
<p>We could parse the string value of <code>id</code> into a number manually inside the controller method before calling into the service, but once again this muddies our controller code with duplicated logic throughout. It would be nice to have a facility to do this for us automatically. </p>
<p>Nest comes to the rescue here!</p>
<h3 id="nest-pipes"><a class="header-link" href="#nest-pipes"></a>Nest Pipes</h3>
<p>Fortunately, we can use another facet of Nest, called Pipes, to manipulate data that comes in from the outside before it reaches our controller. Because we are using TypeScript, Pipes know all the little details about your controller methods, including all the parameters, and the types those parameters are supposed to be. We can take advantage of this information and use <code>class-transformer</code> again to convert a plain object into something of a specific type. Let&#39;s see how to do that.</p>
<p>Open up the <code>DataPipe</code> class and update the <code>transform</code> method to: </p>
<!-- gsr-nest-data-pipe-transform -->
<p><code>src/server/app/util/data.pipe.ts</code></p>
<pre class="hljs"><code>transform(value: <span class="hljs-built_in">any</span>, metadata: ArgumentMetadata) {
  <span class="hljs-keyword">const</span> { metatype } = metadata;
  <span class="hljs-keyword">if</span> (!metatype) {
    <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">const</span> convertedValue = plainToClass(metatype, value);
  <span class="hljs-keyword">return</span> convertedValue;
}</code></pre><p><copy-button></copy-button></p>
<p>The Pipe itself is simple. It implements the <code>PipeTransform</code> interface, and has one method, <code>transform</code>, which is called for each parameter a route handler takes in. </p>
<p>The <code>transform</code> method takes two arguments: the first being the value being passed into the parameter, and the second is meta-data about the parameter itself. This metadata is derived from TypeScript and the <code>emitDecoratorMetadata</code> parameter that is enabled in the <code>tsconfig.json</code> file. When this option enabled, TypeScript automatically includes information about all your object&#39;s types, which can then be used at runtime. This metadata is very powerful and enables some of the functionality you see in Angular and Nest.</p>
<p>Next, we call <code>plainToClass</code>, which converts a value into a particular type, then return the converted value, which becomes the new value for the parameter.</p>
<p>Pipes are bound in all the same ways we saw Interceptors bound earlier. Once again we elect to bind the pipe at the app level, and this is already taken care of in the starter app.</p>
<p>Now, data being passed into all controller handlers will have their types converted automatically. Make a call to <a href="http://localhost:3000/missions/1">http://localhost:3000/missions/1</a>, and you should see a single mission come back.</p>
<h3 id="update-angular-missions-service"><a class="header-link" href="#update-angular-missions-service"></a>Update Angular Missions Service</h3>
<p>We can now pull back a specific mission from our API, so let&#39;s update the mission service in the Ionic project to do just that. </p>
<p>Add the following method to the <code>missions.service.ts</code> service:</p>
<!-- gsr-ng-missions-service-getmissionbyid -->
<p><code>src/client/app/services/missions.service.ts</code></p>
<pre class="hljs"><code>getMissionById(id: <span class="hljs-built_in">number</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
    .get&lt;{data: Mission}&gt;(<span class="hljs-string">`http://localhost:3000/missions/<span class="hljs-subst">${id}</span>`</span>)
    .pipe(map(response =&gt; response.data));
}</code></pre><p><copy-button></copy-button></p>
<h3 id="mission-form"><a class="header-link" href="#mission-form"></a>Mission Form</h3>
<p>The mission form will display in a modal when the user clicks a mission from the list. From here, a user can view the mission, edit, and update it. The mission form is already created as a part of the base solution, so let&#39;s update the <code>MissionFormComponent</code> to pull the selected one back from the service and display it.</p>
<p>Update the <code>MissionFormComponent</code> to use the following <code>ngOnInit</code>:</p>
<!-- gsr-ng-missionform-component-ngoninit -->
<p><code>src/client/app/mission-form/mission-form.component.ts</code></p>
<pre class="hljs"><code>ngOnInit() {
  <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">this</span>.navParams.data.id;
  <span class="hljs-keyword">if</span> (id) {
    <span class="hljs-keyword">this</span>.mission$ = <span class="hljs-keyword">this</span>.missionsService.getMissionById(id);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.mission$ = of({ active: <span class="hljs-literal">false</span> } as <span class="hljs-built_in">any</span>);
  }
}</code></pre><p><copy-button></copy-button></p>
<p>The mission form template is a simple Ionic page that displays the details of the mission in a form. The template is already filled out in the starter app, but here it is for your reference:</p>
<p><code>src/client/app/mission-form/mission-form.component.html</code></p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">ion-header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ion-toolbar</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ion-buttons</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"end"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"close()"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"close"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-icon</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ion-button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ion-buttons</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ion-title</span>&gt;</span>Mission<span class="hljs-tag">&lt;/<span class="hljs-name">ion-title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ion-toolbar</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ion-header</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ion-content</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ion-list</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"(mission$ | async) as mission"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">submit</span>)=<span class="hljs-string">"submit(mission)"</span> #<span class="hljs-attr">form</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-item</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"mission.id"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-label</span>&gt;</span>Id: {{ mission.id }}<span class="hljs-tag">&lt;/<span class="hljs-name">ion-label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"trash"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"danger"</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"end"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-icon</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ion-item</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-label</span> <span class="hljs-attr">position</span>=<span class="hljs-string">"floating"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">ion-label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"mission.title"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-input</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ion-item</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-label</span> <span class="hljs-attr">position</span>=<span class="hljs-string">"floating"</span>&gt;</span>Reward<span class="hljs-tag">&lt;/<span class="hljs-name">ion-label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-input</span>
          <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>
          [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"mission.reward"</span>
          <span class="hljs-attr">name</span>=<span class="hljs-string">"reward"</span>
        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-input</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ion-item</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-label</span>&gt;</span>Active<span class="hljs-tag">&lt;/<span class="hljs-name">ion-label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ion-toggle</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"mission.active"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-toggle</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ion-item</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ion-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">expand</span>=<span class="hljs-string">"block"</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">ion-button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ion-list</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ion-content</span>&gt;</span></code></pre><h3 id="update-mission-list-to-open-mission"><a class="header-link" href="#update-mission-list-to-open-mission"></a>Update Mission List to Open Mission</h3>
<p>We open an Ionic modal and display the <code>MissionForm</code> when a user clicks on a mission in the list. </p>
<p>Update the <code>HomePage</code>file to add the <code>openMission</code> method:</p>
<!-- gsr-ng-home-page-openmission -->
<p><code>src/client/app/home/home.page.ts</code></p>
<pre class="hljs"><code>async openMission(mission: Mission) {
  <span class="hljs-keyword">const</span> modal = await <span class="hljs-keyword">this</span>.modalController.create({
    component: MissionFormComponent,
    componentProps: { id: mission.id }
  });
  await modal.present();
  <span class="hljs-keyword">const</span> { data = {} } = await modal.onDidDismiss();
  <span class="hljs-keyword">if</span> (data.refreshMissions) {
    <span class="hljs-keyword">this</span>.missions = <span class="hljs-keyword">this</span>.missionsService.getMissions();
  }
}</code></pre><p><copy-button></copy-button></p>
<p>The <code>&lt;ion-item&gt;</code> in the home page template has a click handler to call the above method:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">ion-item</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let mission of (missions | async)"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"openMission(mission.id)"</span>&gt;</span></code></pre><p>We will leave the form submission for the next lab.</p>
<h3 id="lab-2-bonus-exercise"><a class="header-link" href="#lab-2-bonus-exercise"></a>Lab 2 Bonus Exercise</h3>
<p>Currently, if we supply an id to the <code>missions/:id</code> endpoint that doesn&#39;t exist, the API returns a null object. We should return a 404 Not Found status code instead.</p>
<p>Update the Nest <code>DataInterceptor</code> to return a NotFoundException if the data is null.</p>
<p>Check the lab2-complete branch for the complete lab2 code and the solution to the exercise.</p>
<h2 id="lab-3"><a class="header-link" href="#lab-3"></a>Lab 3</h2>
<blockquote>
<p>To start fresh at lab3, you can checkout the lab3-start branch in git</p>
</blockquote>
<h3 id="update-nest-missions-service-to-add-create,-update,-and-delete-methods"><a class="header-link" href="#update-nest-missions-service-to-add-create,-update,-and-delete-methods"></a>Update Nest Missions Service to add Create, Update, and Delete Methods</h3>
<p>Add the create, update, and delete methods to the <strong>server</strong> <code>MissionService</code> class:</p>
<!-- gsr-nest-missions-service-createupdatedelete -->
<p><code>src/server/app/missions/missions.service.ts</code></p>
<pre class="hljs"><code>createMission(mission: MissionEntity) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsRepository.create(mission);
}

async updateMission(id: <span class="hljs-built_in">number</span>, mission: MissionEntity) {
  <span class="hljs-keyword">const</span> current = await <span class="hljs-keyword">this</span>.getMission(id);
  <span class="hljs-keyword">if</span> (!current) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  mission.createdAt = current.createdAt;
  mission.createdBy = current.createdBy;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsRepository.update(id, mission);
}

deleteMission(id: <span class="hljs-built_in">number</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsRepository.delete(id);
}</code></pre><p><copy-button></copy-button></p>
<p>The <code>createMission</code> and <code>deleteMission</code> methods are straightforward, just passing through to the mission repository. The <code>updateMission</code> method, however, is making sure we preserve the original <code>createdAt</code> and <code>createdBy</code> values that were originally on the mission. This code is an example of the type of logic that could go into a service class.</p>
<h3 id="update-nest-missions-controller-to-add-post-and-put-methods"><a class="header-link" href="#update-nest-missions-controller-to-add-post-and-put-methods"></a>Update Nest Missions Controller to add Post and PUT Methods</h3>
<p>Add the following methods to the <code>MissionsController</code>:</p>
<!--- gsr-nest-missions-controller-createupdatedelete --->
<p><code>src/server/app/missions/missions.controller.ts</code></p>
<pre class="hljs"><code><span class="hljs-meta">@Post</span>()
async createMission(<span class="hljs-meta">@Body</span>() mission: MissionEntity) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.createMission(mission);
}

<span class="hljs-meta">@Put</span>(<span class="hljs-string">':id'</span>)
async updateMission(<span class="hljs-meta">@Param</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">number</span>, <span class="hljs-meta">@Body</span>() mission: MissionEntity) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.updateMission(id, mission);
}

<span class="hljs-meta">@Delete</span>(<span class="hljs-string">':id'</span>)
async deleteMission(<span class="hljs-meta">@Param</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">number</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.deleteMission(id);
}</code></pre><p><copy-button></copy-button></p>
<p>These new methods each use a new decorator (<code>@Post</code>, <code>@Put</code>, and <code>@Delete</code>) to let Nest know which HTTP method each route handler should respond to.</p>
<p>In the params to both the create and update methods, we use the <code>@Body</code> decorator to indicate we want to populate the <code>mission</code> object from the request body. We don&#39;t need to set up anything additional (like add a body parser), as Nest takes care of this for us.</p>
<p>Additionally, since we are still using the <code>DataPipe</code> that we set up earlier, <code>mission</code> is automatically converted to a MissionEntity class when coming into our route handlers. This conversion is important right now because we set some default values for the <code>createdAt</code> and <code>createdBy</code> properties wouldn&#39;t be set unless this was an actual instance of <code>MemberEntity</code>.</p>
<p>Now that our API supports the remaining create, update, and delete methods, let&#39;s add it to our Ionic app.</p>
<h3 id="update-angular-missions-service-for-create,-update,-and-delete-methods"><a class="header-link" href="#update-angular-missions-service-for-create,-update,-and-delete-methods"></a>Update Angular Missions Service for Create, Update, and Delete methods</h3>
<p>Update the <strong>client</strong> <code>MissionsService</code> class with the remaining methods:</p>
<!-- gsr-ng-missions-service-createupdatedelete -->
<p><code>src/client/app/services/missions.service.ts</code></p>
<pre class="hljs"><code>createMission(mission: Mission) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
    .post&lt;Mission&gt;(<span class="hljs-string">`http://localhost:3000/missions`</span>, mission)
    .toPromise().catch(response =&gt; { <span class="hljs-keyword">throw</span> response.error; });
}

updateMission(mission: Mission) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
    .put&lt;Mission&gt;(<span class="hljs-string">`http://localhost:3000/missions/<span class="hljs-subst">${mission.id}</span>`</span>, mission)
    .toPromise().catch(response =&gt; { <span class="hljs-keyword">throw</span> response.error; });
}

deleteMission(mission: Mission) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
    .delete&lt;Mission&gt;(<span class="hljs-string">`http://localhost:3000/missions/<span class="hljs-subst">${mission.id}</span>`</span>)
    .toPromise().catch(response =&gt; { <span class="hljs-keyword">throw</span> response.error; });
}</code></pre><p><copy-button></copy-button></p>
<p>The new methods above follow the same pattern as before, except now we are using the <code>catchError</code> operator from RXJS to capture any HTTP errors that come back from the API. </p>
<p>With the service methods taken care of, let&#39;s look at updating the mission form next.</p>
<h3 id="updating-mission-form-to-support-create-and-edit"><a class="header-link" href="#updating-mission-form-to-support-create-and-edit"></a>Updating Mission Form to Support Create and Edit</h3>
<p>When the user submits the form on the mission form screen, its setup to call the <code>submit</code> method in <code>MissionFormComponent</code>. Update that class with the following <code>sumbit</code> method:</p>
<!-- gsr-ng-mission-form-component-submit -->
<p><code>src/client/app/mission-form/mission-form.component.ts</code></p>
<pre class="hljs"><code>async submit(mission: Mission) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (mission.id) {
      await <span class="hljs-keyword">this</span>.missionsService.updateMission(mission);
    } <span class="hljs-keyword">else</span> {
      await <span class="hljs-keyword">this</span>.missionsService.createMission(mission);
    }
    <span class="hljs-keyword">this</span>.modalCtrl.dismiss({
      refreshMissions: <span class="hljs-literal">true</span>
    });
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">const</span> alert = await <span class="hljs-keyword">this</span>.alertController.create({
      header: <span class="hljs-string">'API Error'</span>,
      subHeader: error.error,
      message: error.message,
      buttons: [<span class="hljs-string">'OK'</span>]
    });
    await alert.present();
  }
}</code></pre><p><copy-button></copy-button></p>
<p>First, we take a look to see if this is a new mission or an existing one by checking to see if the mission has an id, then we call the appropriate service method based on this check. Next, we subscribe to the call so we can dismiss the modal when it is complete. We also save a reference to the subscription so we can make sure to unsubscribe from it when the call is done, which helps prevent any potential memory leaks.</p>
<h3 id="showing-new-mission-modal"><a class="header-link" href="#showing-new-mission-modal"></a>Showing New Mission Modal</h3>
<p>The last thing we need to do is hook up the add a button to open up the mission form modal. In <code>home.page.html</code>, there is a button in the Ionic header to create new missions, and it is set up to call <code>newMission()</code> when clicked like so:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">ion-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"newMission()"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ion-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-icon</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-button</span>&gt;</span></code></pre><p>Update the <code>newMission</code> method to the class in <code>home.page.ts</code>:</p>
<!-- gsr-ng-home-page-newmission -->
<p><code>src/client/app/home/home.page.ts</code></p>
<pre class="hljs"><code>async newMission() {
  <span class="hljs-keyword">const</span> modal = await <span class="hljs-keyword">this</span>.modalController.create({
    component: MissionFormComponent
  });
  await modal.present();
  <span class="hljs-keyword">const</span> { data = {} } = await modal.onDidDismiss();
  <span class="hljs-keyword">if</span> (data.refreshMissions) {
    <span class="hljs-keyword">this</span>.missions = <span class="hljs-keyword">this</span>.missionsService.getMissions();
  }
}</code></pre><p><copy-button></copy-button></p>
<h3 id="deleting-missions"><a class="header-link" href="#deleting-missions"></a>Deleting Missions</h3>
<p>When the <code>MissionForm</code> modal loads an existing mission, a row displays above the form showing the mission&#39;s ID and a delete icon. Next, we enable the delete icon to allow a user to delete missions.</p>
<p>There is a click handler to the &quot;trash&quot; icon in <code>mission-form.component.html</code>:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">ion-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"trash"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"delete(mission)"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"danger"</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"end"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-icon</span>&gt;</span></code></pre><p>In <code>MissionFormComponent</code>, update the delete method:</p>
<!-- gsr-ng-mission-form-component-delete -->
<p><code>src/client/app/mission-form/mission-form.component.ts</code></p>
<pre class="hljs"><code>async <span class="hljs-keyword">delete</span>(mission: Mission) {
  <span class="hljs-keyword">const</span> alert = await <span class="hljs-keyword">this</span>.alertController.create({
    header: <span class="hljs-string">'Delete Mission?'</span>,
    message: <span class="hljs-string">'Are you sure you want to delete this mission?'</span>,
    buttons: [
      {
        text: <span class="hljs-string">'No'</span>,
        role: <span class="hljs-string">'cancel'</span>,
        cssClass: <span class="hljs-string">'secondary'</span>
      },
      {
        text: <span class="hljs-string">'Yes'</span>,
        handler: async () =&gt; {
          <span class="hljs-keyword">try</span> {
            await <span class="hljs-keyword">this</span>.missionsService.deleteMission(mission);
            <span class="hljs-keyword">this</span>.modalCtrl.dismiss({
              refreshMissions: <span class="hljs-literal">true</span>
            });
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-keyword">const</span> deleteAlert = await <span class="hljs-keyword">this</span>.alertController.create({
              header: <span class="hljs-string">'API Error'</span>,
              subHeader: error.error,
              message: error.message,
              buttons: [<span class="hljs-string">'OK'</span>]
            });
            await deleteAlert.present();
          }
        }
      }
    ]
  });
  await alert.present();
}</code></pre><p><copy-button></copy-button></p>
<p>Now, you can delete missions, and a confirmation alert box will ask you to confirm the deletion.</p>
<p>With all that now in place, we should have a fully functioning app for our space rangers to create, read, update, and delete (CRUD) missions. </p>
<p>When we submit an invalid form (like when a title or reward is missing), we get back a server error that is not too helpful. Next, we will see how to put proper validation in place in our API to make sure the models are valid before we even send them to the database.</p>
<h3 id="validation"><a class="header-link" href="#validation"></a>Validation</h3>
<p>We can now create and update missions, but if we try to submit an incomplete mission, we get a server error that&#39;s not entirely helpful. We will see how to use the <code>class-validator</code> library to help provide validation for our MissionEntity, and how to return back a proper 400 Bad Request error when a validation error occurs.</p>
<p>Class validator offers up many validators that can be applied to members of classes through decorators. We will use a few here to make sure that when an instance of <code>MissionEntity</code> is passed in, that there is a value and that the value type is correct.</p>
<h3 id="add-nest-validators-to-missionentity"><a class="header-link" href="#add-nest-validators-to-missionentity"></a>Add Nest Validators to MissionEntity</h3>
<p>Open up <code>MissionEntity</code> and add some validation decorators to the class:</p>
<p><code>src/server/app/data/mission.entity.ts</code></p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MissionEntity {
  id?: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@IsDefined</span>()
  <span class="hljs-meta">@IsString</span>()
  <span class="hljs-meta">@IsNotEmpty</span>()
  title: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@IsDefined</span>()
  <span class="hljs-meta">@IsNumber</span>()
  reward: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@IsDefined</span>()
  <span class="hljs-meta">@IsBoolean</span>()
  active: <span class="hljs-built_in">boolean</span>;

  <span class="hljs-meta">@Exclude</span>()
  createdAt: <span class="hljs-built_in">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-meta">@Exclude</span>()
  createdBy = <span class="hljs-string">'user'</span>;
}</code></pre><p><copy-button></copy-button></p>
<blockquote>
<p>The IsDefined, IsString, IsNotEmpty, IsNumber, and IsBoolean validators are imported from <code>class-validator</code>;</p>
</blockquote>
<p>Nest Pipes (that we used earlier to convert types on the way in) are also good at validation. In fact, Nest includes a ValidationPipe that utilizes <code>class-validator</code> out of the box. Instead of creating our own validation pipe, we us the built in one. Its already setup in the servers &#39;AppModule&#39; for us:</p>
<pre class="hljs"><code>{
  provide: APP_PIPE,
  useClass: ValidationPipe,
}</code></pre><blockquote>
<p><code>ValidationPipe</code> is imported from &#39;@nestjs/common`.</p>
</blockquote>
<p>Now that you have validation decorators on <code>MissionEntity</code>, the Nest <code>ValidationPipe</code> will return a bad request error with a list of the messages that caused the error. Next, we will parse those errors on the client and display a better error dialog to the user.</p>
<h3 id="update-angular-mission-service-to-process-validation-errors"><a class="header-link" href="#update-angular-mission-service-to-process-validation-errors"></a>Update Angular Mission Service to Process Validation Errors</h3>
<p>When a user tries to create or update a mission and does not provide a title or reward, the API will now throw a bad request status. We need to parse that error response in the service.</p>
<p>In the <strong>client</strong> <code>MissionService</code> add a <code>handleError</code> method that the HTTP responses can use to parse the validation error into a single string:</p>
<!-- gsr-ng-missions-service-handleerror -->
<p><code>src/client/app/services/missions.service.ts</code></p>
<pre class="hljs"><code>handleError(response: <span class="hljs-built_in">any</span>) {
  <span class="hljs-keyword">const</span> { error } = response;
  <span class="hljs-keyword">if</span> (error.statusCode === <span class="hljs-number">400</span>) {
    <span class="hljs-keyword">let</span> message = <span class="hljs-string">''</span>;
    error.message.forEach((msg: <span class="hljs-built_in">any</span>) =&gt; {
      <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(msg.constraints);
      keys.forEach(k =&gt; {
        message += msg.constraints[k] + <span class="hljs-string">'&lt;br /&gt;'</span>;
      });
    });
    <span class="hljs-keyword">throw</span> { message };
  }
  <span class="hljs-keyword">throw</span> error;
}</code></pre><p><copy-button></copy-button></p>
<p>Then update the create, update, and delete methods to use <code>handleError</code> in the promises catch handler:</p>
<pre class="hljs"><code>createMission(mission: Mission) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
    .post&lt;Mission&gt;(<span class="hljs-string">`http://localhost:3000/missions`</span>, mission)
    .toPromise().catch(<span class="hljs-keyword">this</span>.handleError);
}</code></pre><p><copy-button></copy-button></p>
<blockquote>
<p>Make sure to update <code>updateMission</code> and <code>deleteMission</code> as well.</p>
</blockquote>
<p>Now, when you submit an invalid form, you get a proper 400 Bad Request error response. In this example, we loop through the error objects and construct a string showing all the validation issues, but you could do a lot more with it. The errors contain the validation rule that caused the error and the property for which the validation was applied to, so you could go fancier in showing the errors than a simple alert modal.</p>
<h3 id="lab-3-bonus-exercise"><a class="header-link" href="#lab-3-bonus-exercise"></a>Lab 3 Bonus Exercise</h3>
<p>Explore some of the other class validator decorators to add more validation logic to the <code>MissionEntity</code> class. For instance, try the <code>@Min</code> decorator on <code>reward</code> to make the minimum value of reward be greater than or equal to 0. View a list of the available decorators <a href="https://github.com/typestack/class-validator#validation-decorators">here</a>.</p>
<h2 id="lab-4"><a class="header-link" href="#lab-4"></a>Lab 4</h2>
<blockquote>
<p>To start fresh at lab4, you can checkout the lab4-start branch in git</p>
</blockquote>
<h3 id="authentication"><a class="header-link" href="#authentication"></a>Authentication</h3>
<p>Now, let&#39;s see how we can use Authentication in Nest and protect our API endpoints. We make sure that when someone calls one of our protected endpoints that they provide a token that proves who they are. For this sample app, the tokens are contrived values that we manually set, but in a real-world application these would be obtained through some identity (login) system.</p>
<p>Nest provides a mechanism called Guards that function similar to route guards in Angular. A guard is a piece of middleware that runs before a controller gets access to the request (similar to an interceptor) and returns a boolean value that when true lets the request through, or if false, throws a 403 Forbidden response error. In the guard, we inspect the value of the token to help determine if they should be let through or not.</p>
<p>We will also set up a simple role system that contains two roles, users and admins, and only allow these roles to do specific actions:</p>
<ul class="list">
<li><code>GET</code> requests will be open to everyone with no authentication required.</li>
<li><code>POST</code> and <code>PUT</code> requests will require a user or admin role.</li>
<li><code>DELETE</code> requests will require the admin role.</li>
</ul>
<h3 id="nest-roles-decorator"><a class="header-link" href="#nest-roles-decorator"></a>Nest Roles Decorator</h3>
<p>In our base project, we have a <code>Roles</code> decorator that we can use on our controller methods to specify which roles we want the upcoming auth guard to check. </p>
<p>The decorator was created with the Nest CLI, and out of the box does everything we need it to do.</p>
<p>To specify which roles we want a route handler to check for access, we use <code>@Roles(&#39;...&#39;)</code> on each of the controller&#39;s methods. In <code>MissionsController</code> add <code>@Roles</code> and specify the role to the following methods:</p>
<p><code>src/server/app/missions/missions.controller.ts</code></p>
<pre class="hljs"><code><span class="hljs-meta">@Post</span>()
<span class="hljs-meta">@Roles</span>(<span class="hljs-string">'user'</span>)
async createMission(...) { ... }

<span class="hljs-meta">@Put</span>(<span class="hljs-string">':id'</span>)
<span class="hljs-meta">@Roles</span>(<span class="hljs-string">'user'</span>)
async updateMission(...) { ... }

<span class="hljs-meta">@Delete</span>(<span class="hljs-string">':id'</span>)
<span class="hljs-meta">@Roles</span>(<span class="hljs-string">'admin'</span>)
async deleteMission(...) { ... }</code></pre><h3 id="nest-guards"><a class="header-link" href="#nest-guards"></a>Nest Guards</h3>
<p>Open the <strong>server</strong> <code>AuthGuard</code> file, and replace the class&#39;s <code>canActivate</code> method with the following:</p>
<!-- gsr-nest-auth-guard-canactivate -->
<p><code>src/server/app/util/auth.guard.ts</code></p>
<pre class="hljs"><code>canActivate(context: ExecutionContext): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">const</span> request = context.switchToHttp().getRequest();
  <span class="hljs-keyword">let</span> token: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">let</span> user: User;

  <span class="hljs-keyword">if</span> (
    request.headers.authorization &amp;&amp;
    request.headers.authorization.startsWith(<span class="hljs-string">'Bearer '</span>)
  ) {
    token = request.headers.authorization.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">1</span>];
    user = <span class="hljs-keyword">this</span>.userService.getUser(token.replace(<span class="hljs-string">'-token'</span>, <span class="hljs-string">''</span>));
    <span class="hljs-keyword">if</span> (!user) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    request.user = user;
  }

  <span class="hljs-keyword">const</span> requiredRoles =
    <span class="hljs-keyword">this</span>.reflector.get&lt;<span class="hljs-built_in">string</span>[]&gt;(<span class="hljs-string">'roles'</span>, context.getHandler()) || [];

  <span class="hljs-keyword">if</span> (requiredRoles.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">const</span> hasRole = user.roles.some(role =&gt; requiredRoles.indexOf(role) &gt; <span class="hljs-number">-1</span>);
  <span class="hljs-keyword">return</span> hasRole;
}</code></pre><p><copy-button></copy-button></p>
<p>Let&#39;s break the above code down. </p>
<p>First, we check to see if there is an Authorization header, and if there is, we pull the token out of the header and then retrieve the user from the provided users service. If a user is not found, the request is rejected.</p>
<p>Next, we try to pull the list of roles applied to the request handler by checking for a decorator names &quot;roles&quot;, and put those roles into the <code>requiredRoles</code> variable. If the method doesn&#39;t have the decorator, it returns undefined, so we make sure to set <code>requiredRoles</code> to an empty array in that case. If we do have a user, we attach it to the request object so we can access it at a later point in the HTTP request (which we will do in the next section).</p>
<p>If requiredRoles is empty, authentication is not required for this call, so we return true.</p>
<p>Last, we make sure the user has a role that the API call requires.</p>
<p>This guard is already registered with the <strong>server&#39;s</strong> <code>AppModule</code> providers, but here is how it&#39;s done for your reference:</p>
<pre class="hljs"><code>{
  provide: APP_GUARD,
  useClass: AuthGuard,
}</code></pre><p>If you try to use the app now, you see that you can view the list of missions and go to a mission&#39;s details, but you can&#39;t create, edit, or delete them.</p>
<p>The menu button in the top left lets you &quot;login&quot; as a user or admin, and it keeps track of your choice in local storage. However, we don&#39;t currently send the Bearer token in the HTTP request. We will do that next.</p>
<h3 id="angular-http-interceptor"><a class="header-link" href="#angular-http-interceptor"></a>Angular HTTP Interceptor</h3>
<p>In Angular, HTTP Interceptors adds a piece of middleware that will let you modify the outgoing request. Interceptors are a perfect place to add the authorization header if our user is authenticated.</p>
<p>Open the <strong>client</strong> <code>AuthInterceptor</code> class and update the <code>intercept</code> method to:</p>
<!-- gsr-ng-auth-interceptor-intercept --->
<p><code>src/client/app/util/auth.interceptor.ts</code></p>
<pre class="hljs"><code>intercept(
  request: HttpRequest&lt;<span class="hljs-built_in">any</span>&gt;,
  next: HttpHandler
): Observable&lt;HttpEvent&lt;<span class="hljs-built_in">any</span>&gt;&gt; {
  <span class="hljs-keyword">const</span> authToken = <span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">'auth-token'</span>);

  <span class="hljs-keyword">if</span> (!authToken) {
    <span class="hljs-keyword">return</span> next.handle(request);
  }

  <span class="hljs-keyword">const</span> newRequest = request.clone({
    setHeaders: {
      Authorization: <span class="hljs-string">`Bearer <span class="hljs-subst">${authToken}</span>`</span>
    }
  });

  <span class="hljs-keyword">return</span> next.handle(newRequest);
}</code></pre><p><copy-button></copy-button></p>
<p>Interceptors are a simple class that implements an <code>intercept</code> method. In our <code>intercept</code>, we check to make sure if the user is currently &quot;logged in&quot; (by seeing if they have an auth-token value in local storage, which is set by the login screen). If not, the request goes through without any modification. If there is an auth-token, we clone the original request (because requests are immutable, we need a new copy to make changes to it) and add an <code>Authorization</code> header with the auth-token for its value.</p>
<p>The interceptor is already registered in our Angular apps main app module providers:</p>
<pre class="hljs"><code>{
  provide: HTTP_INTERCEPTORS,
  useClass: AuthInterceptor,
  multi: <span class="hljs-literal">true</span>
}</code></pre><p>With the authentication in place, depending on if you log in as a user or admin, you can continue adding, editing, and deleting missions.</p>
<h3 id="accessing-the-authenticated-user-in-the-nest"><a class="header-link" href="#accessing-the-authenticated-user-in-the-nest"></a>Accessing the Authenticated User in the Nest</h3>
<p>Now that we have authentication in place, how do we access the authenticated user? </p>
<p>In the <code>AuthGuard</code>, we attached the user to the request object. Nest does provide a way to get the request object in controllers by using the <code>Request()</code> decorator. We could use this method in our POST handler to get the user and set the correct <code>createdBy</code>  property for the new mission:</p>
<pre class="hljs"><code><span class="hljs-meta">@Roles</span>(<span class="hljs-string">'user'</span>)
<span class="hljs-meta">@Post</span>()
async createMission(<span class="hljs-meta">@Body</span>() mission: MissionEntity, <span class="hljs-meta">@Request</span>() req: <span class="hljs-built_in">any</span>) {
  <span class="hljs-keyword">const</span> user: User = req.user;
  mission.createdBy = user.id;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.createMission(mission);
}</code></pre><p>And while this works, it is not very clean introduces the possibility of having to repeat this code everywhere we want to get the user.</p>
<p>Nest comes to the rescue again by providing the ability to make custom param decorators that have access to the request.</p>
<p>Open the <code>GetUser</code> decorator and update the exported function with the following:</p>
<!-- gsr-nest-getuser-decorator-getuser -->
<p><code>src/server/app/util/getuser.decorator.ts</code></p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> GetUser = createParamDecorator((data, req) =&gt; {
  <span class="hljs-keyword">return</span> req.user;
});</code></pre><p><copy-button></copy-button></p>
<p>The <code>createParamDecorator</code> helper method provided by Nest takes care of all the hard work and gives you direct access to the request object. Here, we simply return the user from the request.</p>
<p>Now, we can update the createMission method to use the new <code>GetUser</code> decorator:</p>
<pre class="hljs"><code><span class="hljs-meta">@Roles</span>(<span class="hljs-string">'user'</span>)
<span class="hljs-meta">@Post</span>()
async createMission(<span class="hljs-meta">@Body</span>() mission: MissionEntity, <span class="hljs-meta">@GetUser</span>() user: User) {
  mission.createdBy = user.id;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.missionsService.createMission(mission);
}</code></pre><p>The <code>GetUser</code> decorator will automatically populate the user param, helps clean up the code and gives a reusable way to retrieve users in other handlers.</p>
<h2 id="conclusion"><a class="header-link" href="#conclusion"></a>Conclusion</h2>
<p>We now have a fully functioning app where we can view lists of missions, see mission details, edit the missions, delete them, and even create a new one. Our space rangers are ready to get to work!</p>
<p>In this tutorial, we used Nest to build out a backend API and saw how it utilizes TypeScript to provide features otherwise impossible in a typical Node app.</p>
<p>On the front end, we have an Angular App powered by the Ionic Framework to build a mobile-first experience for the space rangers.</p>
<p>Together, they made a powerful duo to build out a full-stack TypeScript app. </p>
      </div>
    </div>
  </body>

  <script>
    createButtons();
  </script>
</html>
